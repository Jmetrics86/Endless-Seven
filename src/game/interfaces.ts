import { CardEntity } from '../entities/CardEntity';
import { GameState, Alignment, CardData } from '../types';
import { SealEntity } from '../entities/SealEntity';

export interface IGameController {
  state: GameState;
  playerBattlefield: (CardEntity | null)[];
  enemyBattlefield: (CardEntity | null)[];
  playerHand: CardEntity[];
  playerLimbo: CardEntity[];
  enemyLimbo: CardEntity[];
  playerGraveyard: CardEntity[];
  enemyGraveyard: CardEntity[];
  playerDeck: CardData[];
  enemyDeck: CardData[];
  seals: SealEntity[];
  playerLimboMesh: any;
  enemyLimboMesh: any;
  playerGraveyardMesh: any;
  enemyGraveyardMesh: any;
  sceneManager: any;
  entityManager: any;
  abilityManager: any;
  uiManager: any;
  phaseManager: any;
  isProcessing: boolean;
  currentResolvingSealIndex: number;
  cardsThatBattledThisRound: CardEntity[];
  resolutionCallback: (() => void) | null;
  pendingAbilityData: any;
  nullifyCallback: ((confirmed: boolean) => void) | null;
  sealSelectionCallback: ((idx: number) => void) | null;
  updateState(patch: Partial<GameState>): void;
  addLog(msg: string): void;
  isImmuneToAbilities(target: CardEntity, source: CardEntity): boolean;
  isProtected(card: CardEntity): boolean;
  destroyCard(card: CardEntity, isEnemy: boolean, idx: number, isChampion: boolean, killedBy?: { cardName: string; cause: 'combat' | 'ability' }): void;
  allocateCounters(card: CardEntity, isAI: boolean): Promise<void>;
  handleTargetedAbility(source: CardEntity, isAI: boolean): Promise<void>;
  executeGlobalAbility(source: CardEntity): Promise<void>;
  handleSealTargetAbility(source: CardEntity, isAI: boolean): Promise<void>;
  claimSeal(idx: number, alignment: Alignment): Promise<void>;
  disposeCard(card: CardEntity): void;
  zoomIn(idx: number): void;
  zoomOut(): void;
  handleBattle(attacker: CardEntity, defender: CardEntity, idx: number, isAgainstChamp: boolean): Promise<boolean>;
  handleSiege(idx: number, card: CardEntity | null, isPlayer: boolean): Promise<void>;
  ascendToSeal(card: CardEntity, idx: number): void;
  checkGameOver(): void;
  startPrep(): void;
  endPrep(): void;
  startResolution(): Promise<void>;
  resolveSeal(idx: number): Promise<void>;
  forceSkip(): void;
  selectLimboCardForAbility(zone: 'player' | 'enemy', index: number): void;
}
